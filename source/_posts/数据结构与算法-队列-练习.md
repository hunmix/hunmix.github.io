---
title: 数据结构与算法-队列-练习
date: 2018-05-11 00:24:17
author: hunmix
# img: /source/images/xxx.jpg
# top: true
# cover: true
# coverImg: /images/1.jpg
# toc: false
# mathjax: false
summary: 数据结构, 队列的js实现
categories: 数据结构
tags:
  - 数据结构
---
#### 用js实现一个队列
显示的都写成了console.log的形式，方便看- -
``` js
class Queue {
  constructor () {
    this.dataStore = []
  }
  // 入队
  enqueue (ele) {
    this.dataStore.push(ele)
  }
  // 出队
  dequeue () {
    return this.dataStore.shift()
  }
  // 显示队首元素
  front () {
    // return this.dataStore[0]
    console.log(this.dataStore[0])
  }
  // 显示队尾元素
  back () {
    let len = this.dataStore.length
    // return this.dataStore[len-1]
    console.log(this.dataStore[len-1])
  }
  showQuque () {
    // return this.dataStore
    let str = this.dataStore.join('\n')
    console.log(`--队列--\n${str}\n--------`)
  }
  isEmpty () {
    let len = this.dataStore.length
    if (len > 0) {
      return false
    } else {
      return true
    }
  }
}

module.exports = Queue

```
#### 基数排序
``` js
const Queue = require('./queue')

class RadixSort {
  constructor () {
    this.testInfo = [] // 测试数组
    this.num = 10 // 数字数量
  }
  // 随机生成测试数组
  createTestInfo () {
    let arr = []
    for (let i = 0; i < this.num; i++) {
      arr.push(Math.floor(Math.random() * 100))
    }
    return arr
  }
  // 生成队列实例
  createQueues () {
    const queues = []
    for (let i =0; i < this.num; i++ ) {
      queues[i] = new Queue()
    }
    return queues
  }
  // 根据对应位数放入不同的队列
  sort (digit) {
    let quques = this.createQueues()
    // 按个位数放
    if (digit === 1) {
      this.testInfo.forEach(value => {
        let ququeIndex = value % 10
        quques[ququeIndex].enqueue(value)
      })
      // 按十位数放
    } else {
      this.testInfo.forEach(value => {
        let ququeIndex = Math.floor(value / 10)
        quques[ququeIndex].enqueue(value)
      })
    }
    return this.getResultFromQueues(quques)
  }
  // 把队列中的数组取出放到数组里
  getResultFromQueues (queues) {
    let arr = []
    queues.forEach(queue => {
      while (!queue.isEmpty()) {
        arr.push(queue.dequeue())
      }
    })
    return arr
  }
  // 主函数
  getResult () {
    this.testInfo = this.createTestInfo()
    console.log('原始数组 :')
    console.log(this.testInfo)
    this.testInfo = this.sort(1)
    console.log('第一次排序 :')
    console.log(this.sort(1))
    console.log('第二次排序 :')
    console.log(this.sort(10))
    console.log('-------------我是分界线-------------')
  }
}

// 实例化类
let radixSort = new RadixSort()
// 调用主函数
radixSort.getResult()
radixSort.getResult()
```
**输出结果：** 
``` js
原始数组 :
[ 23, 62, 10, 77, 66, 77, 25, 66, 26, 44 ]
第一次排序 :
[ 10, 62, 23, 44, 25, 66, 66, 26, 77, 77 ]
第二次排序 :
[ 10, 23, 25, 26, 44, 62, 66, 66, 77, 77 ]
-------------我是分界线-------------
原始数组 :
[ 2, 54, 82, 72, 36, 48, 71, 56, 58, 98 ]
第一次排序 :
[ 71, 2, 82, 72, 54, 36, 56, 48, 58, 98 ]
第二次排序 :
[ 2, 36, 48, 54, 56, 58, 71, 72, 82, 98 ]
-------------我是分界线-------------
```
#### 优先队列 
``` js
// 优先队列
class PriorityQueue {
  constructor () {
    this.dataStore = []
  }
  // 入队
  enqueue (ele, code) {
    this.dataStore.push({ele, code})
  }
  // 出队
  dequeue () {
    let index = 0;
    this.dataStore.forEach((value, currentIndex) => {
      if (value.code < this.dataStore[index].code) {
        index = currentIndex
      }
    })
    return this.dataStore.splice(index, 1)
  }
  // 显示队首元素
  front () {
    // return this.dataStore[0]
    console.log(this.dataStore[0])
  }
  // 显示队尾元素
  back () {
    let len = this.dataStore.length
    // return this.dataStore[len-1]
    console.log(this.dataStore[len-1])
  }
  // 展示队列中所有元素
  showQuque () {
    let str = ''
    this.dataStore.forEach(value => {
      str += `ele: ${value.ele} code: ${value.code} \n`
    })
    console.log(str)
  }
  // 是否为空
  isEmpty () {
    let len = this.dataStore.length
    if (len > 0) {
      return false
    } else {
      return true
    }
  }
}

module.exports = PriorityQueue
```

#### 双向队列
** 修复Queue类，形成一个Deque类。这是一个和队列类似的数据结构，允许从队列两端添加和删除元素，因此也叫双向队列。写一段测试程序测试该类：** 
``` js
// 双向队列
class Deque {
  constructor () {
    this.dataStore = []
  }
  // 正向入队
  enqueueForward (ele) {
    this.dataStore.push(ele)
  }
  // 正向出队
  dequeueForward () {
    return this.dataStore.shift()
  }
  // 反向入队
  enqueueBackword (ele) {
    this.dataStore.unshift(ele)
  }
  // 反向出队
  dequeueBackword () {
    return this.dataStore.pop()
  }
  // 显示队首元素
  front () {
    // return this.dataStore[0]
    console.log(this.dataStore[0])
  }
  // 显示队尾元素
  back () {
    let len = this.dataStore.length
    // return this.dataStore[len-1]
    console.log(this.dataStore[len-1])
  }
  showQuque () {
    // return this.dataStore
    let str = this.dataStore.join('')
    console.log(`--队列--\n${str}\n--------`)
    return str
  }
  isEmpty () {
    let len = this.dataStore.length
    if (len > 0) {
      return false
    } else {
      return true
    }
  }
}

module.exports = Deque

```
#### 队列相关题目
##### 回文字符串
**使用前面完成的Deque类来判断一个给定单词是否是回文**
``` js
// 判断是否是回文
const Deque = require('./Deque')

const testInfo = ['abc', 'abccba', 'heiheihei', 'cc']
class TestPalindrome {
  constructor (testInfo) {
    this.testInfo = testInfo
  }
  // 主函数
  testPalindrome () {
    this.testInfo.forEach(value => {
      let value1 = this.addInfoByForworad(value)
      let value2 = this.addInfoByBackworad(value)
      let isEqual = this.isEqual(value1, value2)
      let resultStr = isEqual ? `${value} is palindrome` : `${value} is not palindrome`
      console.log(resultStr)
    })
  }
  // 正向入队
  addInfoByForworad (testInfo) {
    let deque = new Deque()
    for (let i = 0; i < testInfo.length; i++) {
      deque.enqueueForward(testInfo[i])
    }
    return deque.showQuque()
  }
  // 反向入队
  addInfoByBackworad (testInfo) {
    let deque = new Deque()
    for (let i = 0; i < testInfo.length; i++) {
      deque.enqueueBackword(testInfo[i])
    }
    return deque.showQuque()
  }
  // 判断两个值是否相等
  isEqual (value1, value2) {
    let result = value1 === value2 ? true : false
    return result
  }
}

let test = new TestPalindrome(testInfo)
test.testPalindrome()
``` 
**输出结果：**
``` js
abc is not palindrome
abccba is palindrome
heiheihei is not palindrome
cc is palindrome
```


##### 修改优先队列，使得优先级高的元素优先码也越大
``` js
// 修改优先队列，使得优先级高的元素优先码也越大
class PriorityQueue {
  constructor () {
    this.dataStore = []
  }
  // 入队
  enqueue (ele, code) {
    this.dataStore.push({ele, code})
  }
  // 出队
  dequeue () {
    let index = 0;
    this.dataStore.forEach((value, currentIndex) => {
      if (value.code > this.dataStore[index].code) {
        index = currentIndex
      }
    })
    return this.dataStore.splice(index, 1)
  }
  // 显示队首元素
  front () {
    // return this.dataStore[0]
    console.log(this.dataStore[0])
  }
  // 显示队尾元素
  back () {
    let len = this.dataStore.length
    // return this.dataStore[len-1]
    console.log(this.dataStore[len-1])
  }
  // 展示队列中所有元素
  showQuque () {
    let str = ''
    this.dataStore.forEach(value => {
      str += `ele: ${value.ele} code: ${value.code} \n`
    })
    console.log(str)
  }
  // 是否为空
  isEmpty () {
    let len = this.dataStore.length
    if (len > 0) {
      return false
    } else {
      return true
    }
  }
}

module.exports = PriorityQueue

```

**测试代码：**
``` js
const PriorityQueue = require('./priorityQueue')
const PriorityQueue2 = require('./pratice4')
const testInfo = [
  {ele: '第一个', code: 1},
  {ele: '第二个', code: 2},
  {ele: '第三个', code: 3},
  {ele: '第四个', code: 1}
]

// 实例化
const priorityQueue = new PriorityQueue()
const priorityQueue2 = new PriorityQueue2()
// 初始化队列
function initValue (priorityQueue) {
  testInfo.forEach(value => {
    priorityQueue.enqueue(value.ele, value.code)
  })
  return priorityQueue
}
initValue(priorityQueue)
initValue(priorityQueue2)
priorityQueue.showQuque()
console.log(priorityQueue.dequeue())
console.log(priorityQueue.dequeue())
console.log(priorityQueue.dequeue())
console.log(priorityQueue.dequeue())
console.log('----------------------')
console.log(priorityQueue2.dequeue())
console.log(priorityQueue2.dequeue())
console.log(priorityQueue2.dequeue())
console.log(priorityQueue2.dequeue())
```
**输出结果:**
``` js
[ { ele: '第一个', code: 1 } ]
[ { ele: '第四个', code: 1 } ]
[ { ele: '第二个', code: 2 } ]
[ { ele: '第三个', code: 3 } ]
----------------------
[ { ele: '第三个', code: 3 } ]
[ { ele: '第二个', code: 2 } ]
[ { ele: '第一个', code: 1 } ]
[ { ele: '第四个', code: 1 } ]
```
----
**over**
